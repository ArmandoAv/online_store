Files in this folder contain the scripts necessary to create the database objects.

They should be used in the following order:

1. DataModelOracle.sql

This script generates the tables and indexes for the online store model.

The indexes created are as follows:

On the CUSTOMERS table
A composite index is created on FIRSTNAME and LASTNAME.

This is because searches are generally made by the customer's name,
so this index can help make searches more efficient.

On the ORDERS table
An index is created by ORDERDATE.

This is because in addition to being part of one of the requirement points,
It is very common to analyze orders by date and this index helps to make these analyzes faster.

On the ORDERDETAILS table
An index is created by ORDERID.

This is because this table has a very close relationship with the ORDERS table,
so it will be consulted by crossing the ORDERS table and this index will make the crossing more efficient.

2. vw_CustomerOrdersOracle.sql

A view called vw_CustomerOrders is created.
This view shows the CUSTOMERID, FIRSTNAME, LASTNAME, EMAIL, the number of orders placed and the total spent by each customer in the last year (2023).

This script also creates a materialized view and index for this view.

3. sp_MonthlySalesReportOracle.sql

This script creates a store procedure that helps generate a monthly sales report.
The store receives two input parameters (STARTDATE, ENDDATE).

Since this script is a store procedure, a sales report table is created
MONTHLYSALESREPORT

So that when the store is executed, the data can be consulted.
At the moment, there is the functionality that when the store is executed, it deletes the data from the table of the consulted period.

This helps if the procedure is executed several times by different users and if they execute the process with the same period of time, there are no duplicate records or if they execute different periods of time, they can consult their data regardless of whether another user has executed it later. with a different period of time.


4. tr_CheckQuantityOracle.sql

This script generates a trigger called tr_CheckQuantity that validates that the QUANTITY field in the ORDERDETAILS table does not accept quantities less than zero.
To perform the required action, a function called fn_CheckQuantity is created too.

5. fn_CalculateDiscountOracle.sql

This script creates a function called fn_CalculateDiscount, which helps to calculate possible discounts
According to the following rules:

If the quantity is greater than or equal to 10, apply a 10% discount.
If the quantity is greater than or equal to 20, apply a 20% discount.
If the quantity is greater than or equal to 50, apply a 25% discount.

6. fn_ActiveCustomersOracle.sql

This script creates a table function called fn_ActiveCustomers, which returns customers who have placed at least one order in the last 6 months.

7. cte_CategoriesOracle.sql

This script contains a CTE query, which obtains the product categories along with the total number of products sold and the total income generated by each category in the last year (2023).

8. sp_ProcessUpdateDataOracle.sql

This script contains a stored procedure that utilizes the SERIALIZABLE isolation level within the stored procedure. This ensures that transactions are executed in a serializable manner, preventing issues of dirty reads, non-repeatable reads, and phantom reads.

Explanation:

SERIALIZABLE isolation level: This is the highest level of isolation offered by Oracle. It guarantees that transactions appear to execute one after another, even if they are running concurrently. This prevents data inconsistencies that can arise from concurrent transactions reading and writing the same data.

Dirty reads: A dirty read occurs when a transaction reads data that has not yet been committed by another transaction. This can lead to data inconsistencies, as the data read may not be the final state of the data.

Non-repeatable reads: A non-repeatable read occurs when a transaction reads data twice and sees different values. This can happen if another transaction commits changes to the data between the two reads.

Phantom reads: A phantom read occurs when a transaction reads data that did not exist when the transaction started but was created by another transaction before the transaction committed.

By using the SERIALIZABLE isolation level, the stored procedure ensures that these types of data inconsistencies do not occur. This can be important for applications that require a high degree of data consistency.
